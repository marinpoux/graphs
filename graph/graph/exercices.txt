
>EXERCICE 24.2
	-> dans un graphe donné par une matrice d'adjacence, un "1" à l'intersection de deux noeuds
	signifie qu'il y a une connexion dans ce sens, et "0" signifie, pas de connexion.
	dans un graphe non-orienté, toutes les arrêtes (représentées dans la matrice par les intersections),
	vont dans les deux sens : cela signifie que la matrice d'adjacence est entièrement remplie de "1".

	si l'on considère qu'un graphe est défini de la manière suivante :
	typedef struct Graphe
		{
		int nb;				//nombre de sommets = id max
		Sommet *tabSommet;	//tableau de sommets
		char **matrice;		//les valeurs 0 ou 1
		}Graphe;

	algorithme
	ENTREE : un Graphe G
	DEBUT
		POUR i DE 0 A (G->nb - 1)
			POUR j DE 0 A (G->nb - 1)
				//case par case, si on tombe sur une intersection = 0, on arrête et on retourne 0 
				SI (G->matrice[i][j] == 0) FAIRE
				RETOURNER 0
				FINSI
			FINPOUR
		FINPOUR
		//si toutes les cases contiennent 1, on a bien à faire à un graphe non orienté, et on retourne 1
		RETOURNER 1
	FIN

>EXERCICE 24.3
	-> on souhaite finalement, à déterminer si le graph est orienté, c'est à dire que tous les arcs sont à sens unique.
	si on prend la meme structure de graphe que précédemment : 

	algorithme
	algorithme
	ENTREE : un Graphe G
	DEBUT
		POUR i DE 0 A (G->nb - 1)
			POUR j DE 0 A (G->nb - 1)
				//si un arc existe dans les deux sens, le graph est non-orienté et on renvoit 0
				SI (G->matrice[i][j] == G->matrice[j][i]) FAIRE
				RETOURNER 0
				FINSI
			FINPOUR
		FINPOUR
		//si le grap est orienté, "le coloriage est correct" et on renvoit 1
		RETOURNER 1
	FIN

>EXERCICE 25.1
	-> en appliquant un parcours en profondeur sur le graph donné, on devrait visiter les sommets dans l'ordre suivant:
	2, 1, 3, 5, 4, 6
	7, 8, 0, 4, 2, 1, 3, 5, 6, 9